import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect } from "react";
import { useCallback, useMemo } from "react";
import {} from "convex/browser";
import { ConvexProviderWithAuth } from "convex/react";
import {} from "better-auth";
import { createAuthClient } from "better-auth/react";
import { convexClient, crossDomainClient } from "../client/plugins/index.js";
/**
 * A wrapper React component which provides a {@link react.ConvexReactClient}
 * authenticated with Better Auth.
 *
 * @public
 */
export function ConvexBetterAuthProvider({ children, client, authClient, }) {
    const useBetterAuth = useUseAuthFromBetterAuth(authClient);
    useEffect(() => {
        (async () => {
            const url = new URL(window.location?.href);
            const token = url.searchParams.get("ott");
            if (token) {
                const authClientWithCrossDomain = authClient;
                url.searchParams.delete("ott");
                const result = await authClientWithCrossDomain.crossDomain.oneTimeToken.verify({
                    token,
                });
                const session = result.data?.session;
                if (session) {
                    await authClient.getSession({
                        fetchOptions: {
                            headers: {
                                Authorization: `Bearer ${session.token}`,
                            },
                        },
                    });
                    authClientWithCrossDomain.updateSession();
                }
                window.history.replaceState({}, "", url);
            }
        })();
    }, [authClient]);
    return (_jsx(ConvexProviderWithAuth, { client: client, useAuth: useBetterAuth, children: children }));
}
function useUseAuthFromBetterAuth(authClient) {
    return useMemo(() => function useAuthFromBetterAuth() {
        const { data: session, isPending: isSessionPending } = authClient.useSession();
        const sessionId = session?.session?.id;
        const fetchAccessToken = useCallback(async () => {
            try {
                const { data } = await authClient.convex.token();
                return data?.token || null;
            }
            catch {
                return null;
            }
        }, 
        // Build a new fetchAccessToken to trigger setAuth() whenever the
        // session changes.
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [sessionId]);
        return useMemo(() => ({
            isLoading: isSessionPending,
            isAuthenticated: session !== null,
            fetchAccessToken,
        }), 
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [isSessionPending, sessionId, fetchAccessToken]);
    }, [authClient]);
}
//# sourceMappingURL=index.js.map