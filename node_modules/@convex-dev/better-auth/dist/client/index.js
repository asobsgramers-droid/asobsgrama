import { httpActionGeneric, internalMutationGeneric, mutationGeneric, paginationOptsValidator, queryGeneric, } from "convex/server";
import { v } from "convex/values";
import { convexAdapter } from "./adapter.js";
import { betterAuth } from "better-auth";
import { asyncMap } from "convex-helpers";
import { partial } from "convex-helpers/validators";
import { adapterWhereValidator, checkUniqueFields, hasUniqueFields, listOne, paginate, selectFields, } from "./adapterUtils.js";
import { corsRouter } from "convex-helpers/server/cors";
import { version as convexVersion } from "convex";
import semver from "semver";
import defaultSchema from "../component/schema.js";
import { getAuthTables } from "better-auth/db";
export { convexAdapter };
export const getStaticAuth = (createAuth) => {
    return createAuth({}, { optionsOnly: true });
};
if (semver.lt(convexVersion, "1.25.0")) {
    throw new Error("Convex version must be at least 1.25.0");
}
const whereValidator = (schema, tableName) => v.object({
    field: v.union(...Object.keys(schema.tables[tableName].validator.fields).map((field) => v.literal(field)), v.literal("_id")),
    operator: v.optional(v.union(v.literal("lt"), v.literal("lte"), v.literal("gt"), v.literal("gte"), v.literal("eq"), v.literal("in"), v.literal("not_in"), v.literal("ne"), v.literal("contains"), v.literal("starts_with"), v.literal("ends_with"))),
    value: v.union(v.string(), v.number(), v.boolean(), v.array(v.string()), v.array(v.number()), v.null()),
    connector: v.optional(v.union(v.literal("AND"), v.literal("OR"))),
});
export const createApi = (schema, createAuth) => {
    const betterAuthSchema = getAuthTables(getStaticAuth(createAuth).options);
    return {
        migrationRemoveUserId: mutationGeneric({
            args: {
                userId: v.string(),
            },
            handler: async (ctx, args) => {
                await ctx.db.patch(args.userId, {
                    userId: undefined,
                });
            },
        }),
        create: mutationGeneric({
            args: {
                input: v.union(...Object.entries(schema.tables).map(([model, table]) => v.object({
                    model: v.literal(model),
                    data: v.object(table.validator.fields),
                }))),
                select: v.optional(v.array(v.string())),
                onCreateHandle: v.optional(v.string()),
            },
            handler: async (ctx, args) => {
                await checkUniqueFields(ctx, schema, betterAuthSchema, args.input.model, args.input.data);
                const id = await ctx.db.insert(args.input.model, args.input.data);
                const doc = await ctx.db.get(id);
                if (!doc) {
                    throw new Error(`Failed to create ${args.input.model}`);
                }
                const result = selectFields(doc, args.select);
                if (args.onCreateHandle) {
                    await ctx.runMutation(args.onCreateHandle, {
                        model: args.input.model,
                        doc,
                    });
                }
                return result;
            },
        }),
        findOne: queryGeneric({
            args: {
                model: v.union(...Object.keys(schema.tables).map((model) => v.literal(model))),
                where: v.optional(v.array(adapterWhereValidator)),
                select: v.optional(v.array(v.string())),
            },
            handler: async (ctx, args) => {
                return await listOne(ctx, schema, betterAuthSchema, args);
            },
        }),
        findMany: queryGeneric({
            args: {
                model: v.union(...Object.keys(schema.tables).map((model) => v.literal(model))),
                where: v.optional(v.array(adapterWhereValidator)),
                limit: v.optional(v.number()),
                sortBy: v.optional(v.object({
                    direction: v.union(v.literal("asc"), v.literal("desc")),
                    field: v.string(),
                })),
                offset: v.optional(v.number()),
                paginationOpts: paginationOptsValidator,
            },
            handler: async (ctx, args) => {
                return await paginate(ctx, schema, betterAuthSchema, args);
            },
        }),
        updateOne: mutationGeneric({
            args: {
                input: v.union(...Object.entries(schema.tables).map(([name, table]) => {
                    const tableName = name;
                    const fields = partial(table.validator.fields);
                    return v.object({
                        model: v.literal(tableName),
                        update: v.object(fields),
                        where: v.optional(v.array(whereValidator(schema, tableName))),
                    });
                })),
                onUpdateHandle: v.optional(v.string()),
            },
            handler: async (ctx, args) => {
                const doc = await listOne(ctx, schema, betterAuthSchema, args.input);
                if (!doc) {
                    throw new Error(`Failed to update ${args.input.model}`);
                }
                await checkUniqueFields(ctx, schema, betterAuthSchema, args.input.model, args.input.update, doc);
                await ctx.db.patch(doc._id, args.input.update);
                const updatedDoc = await ctx.db.get(doc._id);
                if (!updatedDoc) {
                    throw new Error(`Failed to update ${args.input.model}`);
                }
                if (args.onUpdateHandle) {
                    await ctx.runMutation(args.onUpdateHandle, {
                        model: args.input.model,
                        newDoc: updatedDoc,
                        oldDoc: doc,
                    });
                }
                return updatedDoc;
            },
        }),
        updateMany: mutationGeneric({
            args: {
                input: v.union(...Object.entries(schema.tables).map(([name, table]) => {
                    const tableName = name;
                    const fields = partial(table.validator.fields);
                    return v.object({
                        model: v.literal(tableName),
                        update: v.object(fields),
                        where: v.optional(v.array(whereValidator(schema, tableName))),
                    });
                })),
                paginationOpts: paginationOptsValidator,
                onUpdateHandle: v.optional(v.string()),
            },
            handler: async (ctx, args) => {
                const { page, ...result } = await paginate(ctx, schema, betterAuthSchema, {
                    ...args.input,
                    paginationOpts: args.paginationOpts,
                });
                if (args.input.update) {
                    if (hasUniqueFields(betterAuthSchema, args.input.model, args.input.update ?? {}) &&
                        page.length > 1) {
                        throw new Error(`Attempted to set unique fields in multiple documents in ${args.input.model} with the same value. Fields: ${Object.keys(args.input.update ?? {}).join(", ")}`);
                    }
                    await asyncMap(page, async (doc) => {
                        await checkUniqueFields(ctx, schema, betterAuthSchema, args.input.model, args.input.update ?? {}, doc);
                        await ctx.db.patch(doc._id, args.input.update);
                        if (args.onUpdateHandle) {
                            await ctx.runMutation(args.onUpdateHandle, {
                                model: args.input.model,
                                newDoc: await ctx.db.get(doc._id),
                                oldDoc: doc,
                            });
                        }
                    });
                }
                return {
                    ...result,
                    count: page.length,
                    ids: page.map((doc) => doc._id),
                };
            },
        }),
        deleteOne: mutationGeneric({
            args: {
                input: v.union(...Object.keys(schema.tables).map((name) => {
                    const tableName = name;
                    return v.object({
                        model: v.literal(tableName),
                        where: v.optional(v.array(whereValidator(schema, tableName))),
                    });
                })),
                onDeleteHandle: v.optional(v.string()),
            },
            handler: async (ctx, args) => {
                const doc = await listOne(ctx, schema, betterAuthSchema, args.input);
                if (!doc) {
                    return;
                }
                await ctx.db.delete(doc._id);
                if (args.onDeleteHandle) {
                    await ctx.runMutation(args.onDeleteHandle, { model: args.input.model, doc });
                }
                return doc;
            },
        }),
        deleteMany: mutationGeneric({
            args: {
                input: v.union(...Object.keys(schema.tables).map((name) => {
                    const tableName = name;
                    return v.object({
                        model: v.literal(tableName),
                        where: v.optional(v.array(whereValidator(schema, tableName))),
                    });
                })),
                paginationOpts: paginationOptsValidator,
                onDeleteHandle: v.optional(v.string()),
            },
            handler: async (ctx, args) => {
                const { page, ...result } = await paginate(ctx, schema, betterAuthSchema, {
                    ...args.input,
                    paginationOpts: args.paginationOpts,
                });
                await asyncMap(page, async (doc) => {
                    if (args.onDeleteHandle) {
                        await ctx.runMutation(args.onDeleteHandle, {
                            model: args.input.model,
                            doc,
                        });
                    }
                    await ctx.db.delete(doc._id);
                });
                return {
                    ...result,
                    count: page.length,
                    ids: page.map((doc) => doc._id),
                };
            },
        }),
    };
};
export const createClient = (component, config) => {
    const safeGetAuthUser = async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
            return;
        }
        const doc = (await ctx.runQuery(component.adapter.findOne, {
            model: "user",
            where: [
                {
                    field: "_id",
                    value: identity.subject,
                },
            ],
        }));
        if (!doc) {
            return;
        }
        return doc;
    };
    const getHeaders = async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
            return new Headers();
        }
        const session = await ctx.runQuery(component.adapter.findOne, {
            model: "session",
            where: [
                {
                    field: "_id",
                    value: identity.sessionId,
                },
            ],
        });
        return new Headers({
            ...(session?.token ? { authorization: `Bearer ${session.token}` } : {}),
            ...(session?.ipAddress
                ? { "x-forwarded-for": session.ipAddress }
                : {}),
        });
    };
    return {
        component,
        adapter: (ctx) => convexAdapter(ctx, component, {
            ...config,
            debugLogs: config?.verbose,
        }),
        getAuth: async (createAuth, ctx) => ({
            auth: createAuth(ctx),
            headers: await getHeaders(ctx),
        }),
        getHeaders,
        /**
         * Returns the current user or null if the user is not found
         * @param ctx - The Convex context
         * @returns The user or null if the user is not found
         */
        safeGetAuthUser,
        /**
         * Returns the current user.
         * @param ctx - The Convex context
         * @returns The user or throws an error if the user is not found
         */
        getAuthUser: async (ctx) => {
            const user = await safeGetAuthUser(ctx);
            if (!user) {
                throw new Error("Unauthenticated");
            }
            return user;
        },
        /**
         * Returns a user by their Better Auth user id.
         * @param ctx - The Convex context
         * @param id - The Better Auth user id
         * @returns The user or null if the user is not found
         */
        getAnyUserById: async (ctx, id) => {
            return (await ctx.runQuery(component.adapter.findOne, {
                model: "user",
                where: [{ field: "_id", value: id }],
            }));
        },
        // Replaces 0.7 behavior of returning a new user id from
        // onCreateUser, deprecated in 0.9
        /**
         * Replaces 0.7 behavior of returning a new user id from
         * onCreateUser
         * @param ctx - The Convex context
         * @param authId - The Better Auth user id
         * @param userId - The app user id
         * @deprecated in 0.9
         */
        setUserId: async (ctx, authId, userId) => {
            await ctx.runMutation(component.adapter.updateOne, {
                input: {
                    model: "user",
                    where: [{ field: "_id", value: authId }],
                    update: { userId },
                },
            });
        },
        /**
         * Temporary method to simplify 0.9 migration, gets a user by `userId` field
         * @param ctx - The Convex context
         * @param userId - The app user id
         * @returns The user or null if the user is not found
         */
        migrationGetUser: async (ctx, userId) => {
            return (await ctx.runQuery(component.adapter.findOne, {
                model: "user",
                where: [{ field: "userId", value: userId }],
            }));
        },
        /**
         * Temporary method to simplify 0.9 migration, removes the `userId` field
         * from the Better Auth user record
         * @param ctx - The Convex context
         * @param userId - The app user id
         */
        migrationRemoveUserId: async (ctx, userId) => {
            if (!component.adapter.migrationRemoveUserId) {
                throw new Error("migrationRemoveUserId not found");
            }
            await ctx.runMutation(component.adapter.migrationRemoveUserId, {
                userId,
            });
        },
        triggersApi: () => ({
            onCreate: internalMutationGeneric({
                args: {
                    doc: v.any(),
                    model: v.string(),
                },
                handler: async (ctx, args) => {
                    await config?.triggers?.[args.model]?.onCreate?.(ctx, args.doc);
                },
            }),
            onUpdate: internalMutationGeneric({
                args: {
                    oldDoc: v.any(),
                    newDoc: v.any(),
                    model: v.string(),
                },
                handler: async (ctx, args) => {
                    await config?.triggers?.[args.model]?.onUpdate?.(ctx, args.newDoc, args.oldDoc);
                },
            }),
            onDelete: internalMutationGeneric({
                args: {
                    doc: v.any(),
                    model: v.string(),
                },
                handler: async (ctx, args) => {
                    await config?.triggers?.[args.model]?.onDelete?.(ctx, args.doc);
                },
            }),
        }),
        registerRoutes: (http, createAuth, opts = {}) => {
            const staticAuth = getStaticAuth(createAuth);
            const path = staticAuth.options.basePath ?? "/api/auth";
            const authRequestHandler = httpActionGeneric(async (ctx, request) => {
                if (config?.verbose) {
                    console.log("options.baseURL", staticAuth.options.baseURL);
                    console.log("request headers", request.headers);
                }
                const auth = createAuth(ctx);
                const response = await auth.handler(request);
                if (config?.verbose) {
                    console.log("response headers", response.headers);
                }
                return response;
            });
            const wellKnown = http.lookup("/.well-known/openid-configuration", "GET");
            // If registerRoutes is used multiple times, this may already be defined
            if (!wellKnown) {
                // Redirect root well-known to api well-known
                http.route({
                    path: "/.well-known/openid-configuration",
                    method: "GET",
                    handler: httpActionGeneric(async () => {
                        const url = `${process.env.CONVEX_SITE_URL}${path}/convex/.well-known/openid-configuration`;
                        return Response.redirect(url);
                    }),
                });
            }
            if (!opts.cors) {
                http.route({
                    pathPrefix: `${path}/`,
                    method: "GET",
                    handler: authRequestHandler,
                });
                http.route({
                    pathPrefix: `${path}/`,
                    method: "POST",
                    handler: authRequestHandler,
                });
                return;
            }
            const corsOpts = typeof opts.cors === "boolean"
                ? { allowedOrigins: [], allowedHeaders: [], exposedHeaders: [] }
                : opts.cors;
            let trustedOriginsOption;
            const cors = corsRouter(http, {
                allowedOrigins: async (request) => {
                    trustedOriginsOption =
                        trustedOriginsOption ??
                            (await staticAuth.$context).options.trustedOrigins ??
                            [];
                    const trustedOrigins = Array.isArray(trustedOriginsOption)
                        ? trustedOriginsOption
                        : await trustedOriginsOption(request);
                    return trustedOrigins
                        .map((origin) => 
                    // Strip trailing wildcards, unsupported for allowedOrigins
                    origin.endsWith("*") && origin.length > 1
                        ? origin.slice(0, -1)
                        : origin)
                        .concat(corsOpts.allowedOrigins ?? []);
                },
                allowCredentials: true,
                allowedHeaders: [
                    "Content-Type",
                    "Better-Auth-Cookie",
                    "Authorization",
                ].concat(corsOpts.allowedHeaders ?? []),
                exposedHeaders: ["Set-Better-Auth-Cookie"].concat(corsOpts.exposedHeaders ?? []),
                debug: config?.verbose,
                enforceAllowOrigins: false,
            });
            cors.route({
                pathPrefix: `${path}/`,
                method: "GET",
                handler: authRequestHandler,
            });
            cors.route({
                pathPrefix: `${path}/`,
                method: "POST",
                handler: authRequestHandler,
            });
        },
    };
};
//# sourceMappingURL=index.js.map