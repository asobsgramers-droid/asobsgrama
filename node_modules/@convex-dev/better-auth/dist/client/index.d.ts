import { type DataModelFromSchemaDefinition, type DefaultFunctionArgs, type FunctionReference, type GenericActionCtx, type GenericDataModel, type GenericMutationCtx, type GenericQueryCtx, type GenericSchema, type HttpRouter, type SchemaDefinition } from "convex/server";
import { type Infer } from "convex/values";
import { convexAdapter } from "./adapter.js";
import { type Auth, betterAuth } from "better-auth";
import type { DBAdapterInstance } from "better-auth/adapters";
import defaultSchema from "../component/schema.js";
import type { ComponentApi } from "../component/_generated/component.js";
import type { TableNames } from "../component/_generated/dataModel.js";
export { convexAdapter };
export type CreateAdapter = <Ctx extends GenericCtx<GenericDataModel>>(ctx: Ctx) => DBAdapterInstance;
export type CreateAuth<DataModel extends GenericDataModel, A extends ReturnType<typeof betterAuth> = Auth> = ((ctx: GenericCtx<DataModel>) => A) | ((ctx: GenericCtx<DataModel>, opts?: {
    optionsOnly?: boolean;
}) => A);
export declare const getStaticAuth: <DataModel extends GenericDataModel, Auth extends ReturnType<typeof betterAuth>>(createAuth: CreateAuth<DataModel, Auth>) => Auth;
export type EventFunction<T extends DefaultFunctionArgs> = FunctionReference<"mutation", "internal" | "public", T>;
export type GenericCtx<DataModel extends GenericDataModel = GenericDataModel> = GenericQueryCtx<DataModel> | GenericMutationCtx<DataModel> | GenericActionCtx<DataModel>;
export type AuthFunctions = {
    onCreate?: FunctionReference<"mutation", "internal", {
        [key: string]: any;
    }>;
    onUpdate?: FunctionReference<"mutation", "internal", {
        [key: string]: any;
    }>;
    onDelete?: FunctionReference<"mutation", "internal", {
        [key: string]: any;
    }>;
};
export declare const createApi: <DataModel extends GenericDataModel, Schema extends SchemaDefinition<any, any>>(schema: Schema, createAuth: CreateAuth<DataModel>) => {
    migrationRemoveUserId: import("convex/server").RegisteredMutation<"public", {
        userId: string;
    }, Promise<void>>;
    create: import("convex/server").RegisteredMutation<"public", {
        select?: string[] | undefined;
        onCreateHandle?: string | undefined;
        input: {
            model: string;
            data: {
                [x: string]: any;
                [x: number]: any;
                [x: symbol]: any;
            };
        };
    }, Promise<any>>;
    findOne: import("convex/server").RegisteredQuery<"public", {
        where?: {
            operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
            connector?: "AND" | "OR" | undefined;
            value: string | number | boolean | string[] | number[] | null;
            field: string;
        }[] | undefined;
        select?: string[] | undefined;
        model: string;
    }, Promise<import("convex/server").GenericDocument | null>>;
    findMany: import("convex/server").RegisteredQuery<"public", {
        where?: {
            operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
            connector?: "AND" | "OR" | undefined;
            value: string | number | boolean | string[] | number[] | null;
            field: string;
        }[] | undefined;
        sortBy?: {
            field: string;
            direction: "asc" | "desc";
        } | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
        model: string;
        paginationOpts: {
            id?: number;
            endCursor?: string | null;
            maximumRowsRead?: number;
            maximumBytesRead?: number;
            numItems: number;
            cursor: string | null;
        };
    }, Promise<import("convex/server").PaginationResult<import("convex/server").GenericDocument>>>;
    updateOne: import("convex/server").RegisteredMutation<"public", {
        onUpdateHandle?: string | undefined;
        input: {
            where?: {
                operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
                connector?: "AND" | "OR" | undefined;
                value: string | number | boolean | string[] | number[] | null;
                field: string;
            }[] | undefined;
            update: {
                [x: string]: unknown;
                [x: number]: unknown;
                [x: symbol]: unknown;
            };
            model: TableNames;
        };
    }, Promise<any>>;
    updateMany: import("convex/server").RegisteredMutation<"public", {
        onUpdateHandle?: string | undefined;
        input: {
            where?: {
                operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
                connector?: "AND" | "OR" | undefined;
                value: string | number | boolean | string[] | number[] | null;
                field: string;
            }[] | undefined;
            update: {
                [x: string]: unknown;
                [x: number]: unknown;
                [x: symbol]: unknown;
            };
            model: TableNames;
        };
        paginationOpts: {
            id?: number;
            endCursor?: string | null;
            maximumRowsRead?: number;
            maximumBytesRead?: number;
            numItems: number;
            cursor: string | null;
        };
    }, Promise<{
        count: number;
        ids: import("convex/values").Value[];
        isDone: boolean;
        continueCursor: import("convex/server").Cursor;
        splitCursor?: import("convex/server").Cursor | null;
        pageStatus?: "SplitRecommended" | "SplitRequired" | null;
    }>>;
    deleteOne: import("convex/server").RegisteredMutation<"public", {
        onDeleteHandle?: string | undefined;
        input: {
            where?: {
                operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
                connector?: "AND" | "OR" | undefined;
                value: string | number | boolean | string[] | number[] | null;
                field: string;
            }[] | undefined;
            model: TableNames;
        };
    }, Promise<import("convex/server").GenericDocument | undefined>>;
    deleteMany: import("convex/server").RegisteredMutation<"public", {
        onDeleteHandle?: string | undefined;
        input: {
            where?: {
                operator?: "lt" | "lte" | "gt" | "gte" | "eq" | "in" | "not_in" | "ne" | "contains" | "starts_with" | "ends_with" | undefined;
                connector?: "AND" | "OR" | undefined;
                value: string | number | boolean | string[] | number[] | null;
                field: string;
            }[] | undefined;
            model: TableNames;
        };
        paginationOpts: {
            id?: number;
            endCursor?: string | null;
            maximumRowsRead?: number;
            maximumBytesRead?: number;
            numItems: number;
            cursor: string | null;
        };
    }, Promise<{
        count: number;
        ids: import("convex/values").Value[];
        isDone: boolean;
        continueCursor: import("convex/server").Cursor;
        splitCursor?: import("convex/server").Cursor | null;
        pageStatus?: "SplitRecommended" | "SplitRequired" | null;
    }>>;
};
export type Triggers<DataModel extends GenericDataModel, Schema extends SchemaDefinition<any, any>> = {
    [K in keyof Schema["tables"]]?: {
        onCreate?: <Ctx extends GenericMutationCtx<DataModel>>(ctx: Ctx, doc: Infer<Schema["tables"][K]["validator"]> & {
            _id: string;
            _creationTime: number;
        }) => Promise<void>;
        onUpdate?: <Ctx extends GenericMutationCtx<DataModel>>(ctx: Ctx, newDoc: Infer<Schema["tables"][K]["validator"]> & {
            _id: string;
            _creationTime: number;
        }, oldDoc: Infer<Schema["tables"][K]["validator"]> & {
            _id: string;
            _creationTime: number;
        }) => Promise<void>;
        onDelete?: <Ctx extends GenericMutationCtx<DataModel>>(ctx: Ctx, doc: Infer<Schema["tables"][K]["validator"]> & {
            _id: string;
            _creationTime: number;
        }) => Promise<void>;
    };
};
type SlimComponentApi = {
    adapter: {
        create: FunctionReference<"mutation", "internal">;
        findOne: FunctionReference<"query", "internal">;
        findMany: FunctionReference<"query", "internal">;
        updateOne: FunctionReference<"mutation", "internal">;
        updateMany: FunctionReference<"mutation", "internal">;
        deleteOne: FunctionReference<"mutation", "internal">;
        deleteMany: FunctionReference<"mutation", "internal">;
        migrationRemoveUserId?: FunctionReference<"mutation", "internal">;
    };
    adapterTest?: ComponentApi["adapterTest"];
};
export declare const createClient: <DataModel extends GenericDataModel, Schema extends SchemaDefinition<GenericSchema, true> = typeof defaultSchema, Api extends SlimComponentApi = SlimComponentApi>(component: Api, config?: {
    local?: {
        schema?: Schema;
    };
    verbose?: boolean;
} & ({
    triggers: Triggers<DataModel, Schema>;
    authFunctions: AuthFunctions;
} | {
    triggers?: undefined;
})) => {
    component: Api;
    adapter: (ctx: GenericCtx<DataModel>) => import("better-auth/adapters").AdapterFactory;
    getAuth: <T extends CreateAuth<DataModel>>(createAuth: T, ctx: GenericCtx<DataModel>) => Promise<{
        auth: ReturnType<T>;
        headers: Headers;
    }>;
    getHeaders: (ctx: GenericCtx<DataModel>) => Promise<Headers>;
    /**
     * Returns the current user or null if the user is not found
     * @param ctx - The Convex context
     * @returns The user or null if the user is not found
     */
    safeGetAuthUser: (ctx: GenericCtx<DataModel>) => Promise<DataModelFromSchemaDefinition<Schema>["user"]["document"] | undefined>;
    /**
     * Returns the current user.
     * @param ctx - The Convex context
     * @returns The user or throws an error if the user is not found
     */
    getAuthUser: (ctx: GenericCtx<DataModel>) => Promise<DataModelFromSchemaDefinition<Schema>["user"]["document"]>;
    /**
     * Returns a user by their Better Auth user id.
     * @param ctx - The Convex context
     * @param id - The Better Auth user id
     * @returns The user or null if the user is not found
     */
    getAnyUserById: (ctx: GenericCtx<DataModel>, id: string) => Promise<DataModelFromSchemaDefinition<Schema>["user"]["document"] | null>;
    /**
     * Replaces 0.7 behavior of returning a new user id from
     * onCreateUser
     * @param ctx - The Convex context
     * @param authId - The Better Auth user id
     * @param userId - The app user id
     * @deprecated in 0.9
     */
    setUserId: (ctx: GenericMutationCtx<DataModel>, authId: string, userId: string) => Promise<void>;
    /**
     * Temporary method to simplify 0.9 migration, gets a user by `userId` field
     * @param ctx - The Convex context
     * @param userId - The app user id
     * @returns The user or null if the user is not found
     */
    migrationGetUser: (ctx: GenericMutationCtx<DataModel>, userId: string) => Promise<DataModelFromSchemaDefinition<Schema>["user"]["document"] | null>;
    /**
     * Temporary method to simplify 0.9 migration, removes the `userId` field
     * from the Better Auth user record
     * @param ctx - The Convex context
     * @param userId - The app user id
     */
    migrationRemoveUserId: (ctx: GenericMutationCtx<DataModel>, userId: string) => Promise<void>;
    triggersApi: () => {
        onCreate: import("convex/server").RegisteredMutation<"internal", {
            model: string;
            doc: any;
        }, Promise<void>>;
        onUpdate: import("convex/server").RegisteredMutation<"internal", {
            model: string;
            newDoc: any;
            oldDoc: any;
        }, Promise<void>>;
        onDelete: import("convex/server").RegisteredMutation<"internal", {
            model: string;
            doc: any;
        }, Promise<void>>;
    };
    registerRoutes: (http: HttpRouter, createAuth: CreateAuth<DataModel>, opts?: {
        cors?: boolean | {
            allowedOrigins?: string[];
            allowedHeaders?: string[];
            exposedHeaders?: string[];
        };
    }) => void;
};
//# sourceMappingURL=index.d.ts.map