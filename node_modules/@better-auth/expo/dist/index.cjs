'use strict';

const api = require('better-auth/api');
const zod = require('zod');

const expo = (options) => {
  return {
    id: "expo",
    init: (ctx) => {
      const trustedOrigins = process.env.NODE_ENV === "development" ? ["exp://"] : [];
      return {
        options: {
          trustedOrigins
        }
      };
    },
    async onRequest(request, ctx) {
      if (!options?.overrideOrigin || request.headers.get("origin")) {
        return;
      }
      const expoOrigin = request.headers.get("expo-origin");
      if (!expoOrigin) {
        return;
      }
      const req = request.clone();
      req.headers.set("origin", expoOrigin);
      return {
        request: req
      };
    },
    hooks: {
      after: [
        {
          matcher(context) {
            return context.path?.startsWith("/callback") || context.path?.startsWith("/oauth2/callback");
          },
          handler: api.createAuthMiddleware(async (ctx) => {
            const headers = ctx.context.responseHeaders;
            const location = headers?.get("location");
            if (!location) {
              return;
            }
            const isProxyURL = location.includes("/oauth-proxy-callback");
            if (isProxyURL) {
              return;
            }
            const trustedOrigins = ctx.context.trustedOrigins.filter(
              (origin) => !origin.startsWith("http")
            );
            const isTrustedOrigin = trustedOrigins.some(
              (origin) => location?.startsWith(origin)
            );
            if (!isTrustedOrigin) {
              return;
            }
            const cookie = headers?.get("set-cookie");
            if (!cookie) {
              return;
            }
            const url = new URL(location);
            url.searchParams.set("cookie", cookie);
            ctx.setHeader("location", url.toString());
          })
        }
      ]
    },
    endpoints: {
      expoAuthorizationProxy: api.createAuthEndpoint(
        "/expo-authorization-proxy",
        {
          method: "GET",
          query: zod.z.object({
            authorizationURL: zod.z.string()
          }),
          metadata: {
            isAction: false
          }
        },
        async (ctx) => {
          const { authorizationURL } = ctx.query;
          const url = new URL(authorizationURL);
          const state = url.searchParams.get("state");
          if (!state) {
            throw new api.APIError("BAD_REQUEST", {
              message: "Unexpected error"
            });
          }
          const stateCookie = ctx.context.createAuthCookie("state", {
            maxAge: 5 * 60 * 1e3
            // 5 minutes
          });
          await ctx.setSignedCookie(
            stateCookie.name,
            state,
            ctx.context.secret,
            stateCookie.attributes
          );
          return ctx.redirect(ctx.query.authorizationURL);
        }
      )
    }
  };
};

exports.expo = expo;
